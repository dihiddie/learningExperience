Делегаты представляют такие объекты, которые указывают на методы. То есть делегаты - это указатели на методы и с помощью делегатов мы можем вызвать данные методы

<pre class="cscode"><code><span class="key">class</span> Program
    {
        <span class="key">delegate</span> <span class="key">void</span> Message(); <span class="com">// 1. Объявляем делегат</span>
     
        <span class="key">static</span> <span class="key">void</span> Main(<span class="key">string</span>[] args)
        {
            Message mes; <span class="com">// 2. Создаем переменную делегата</span>
            <span class="key">if</span> (DateTime.Now.Hour &lt; 12)
            {
                mes = GoodMorning; <span class="com">// 3. Присваиваем этой переменной адрес метода</span>
            }
            <span class="key">else</span>
            {
                mes = GoodEvening;
            }
            mes(); <span class="com">// 4. Вызываем метод</span>
            Console.ReadKey();
        }
        <span class="key">private</span> <span class="key">static</span> <span class="key">void</span> GoodMorning()
        {
            Console.WriteLine(<span class="str">"Good Morning"</span>);
        }
        <span class="key">private</span> <span class="key">static</span> <span class="key">void</span> GoodEvening()
        {
            Console.WriteLine(<span class="str">"Good Evening"</span>);
        }
    }</code></pre>
    <p>В каком-то смысле вы можете думать о типе делегата как о некоем интерфейсе, в котором определён лишь один метод с чётко заданной сигнатурой (в этой статье под сигнатурой метода я буду понимать все его входные и выходные (ref и out) параметры, а также возвращаемое значение). Тогда экземпляр делегата — это объект, реализующий этот интерфейс. В этом понимании, имея экземпляр делегата, вы можете вызвать любой существующий метод, сигнатура которого будет совпадать с сигнатурой метода, определённого в «интерфейсе». Делегаты обладают и другой функциональностью, но возможность делать вызовы методов с заранее определёнными сигнатурами — это и есть самая суть делегатов. Экземпляр делегата хранит ссылку (указатель, метку) на целевой метод и, если этот метод является экземплярным, то и ссылку на экземпляр объекта (класса или структуры), в котором «находится» целевой метод.
    </p>
    В .NET есть несколько встроенных делегатов, которые используются в различных ситуациях. И наиболее используемыми, с которыми часто приходится сталкиваться, являются Action, Predicate и Func.
    <h6>Action</h6>
Делегат Action является обобщенным, принимает параметры и возвращает значение void
public delegate void Action<T>(T obj)
Данный делегат имеет ряд перегруженных версий. Каждая версия принимает разное число параметров: от Action<in T1> до Action<in T1, in T2,....in T16>. Таким образом можно передать до 16 значений в метод.
    <h6>Predicate</h6>
Делегат Predicate<T>, как правило, используется для сравнения, сопоставления некоторого объекта T определенному условию. В качестве выходного результата возвращается значение true, если условие соблюдено, и false, если не соблюдено
    <h6>Func</h6>
Еще одним распространенным делегатом является Func. Он возвращает результат действия и может принимать параметры. Он также имеет различные формы: от Func<out T>(), где T - тип возвращаемого значения, до Func<in T1, in T2,...in T16, out TResult>(), то есть может принимать до 16 параметров.

